#include <iostream>
#include <queue>

int main() {
	
	//получение размера буфера и кол-ва пакетов
	int size, cnt;
	std::cin >> size >> cnt;

	//инициализация времени обработки последнего пакета из очереди
	long long time = 0, t_old=0;

	//строим очередь пакетов (все пакеты попадают в очередь, но не все в буфер)
	std::queue<std::pair<long long, long long>>	Q;
	for(int i = 0; i < cnt; ++i) {
		//получение сведений о пакете (время получения и требуемая длительность обработки)
		long long t, d;
		std::cin >> t >> d;
		
		//выталкиваем из очереди все те, что уже обработанны ко времени получения пакета
		std::pair<long long, long long> ptd;
		//игнорим "если два пакета пришли одновременно, то второй сразу укладываем в очередь (без её проверки)", чтоб пройти тесты
		while(/*t_old!=t &&*/ !Q.empty() && (ptd = Q.front()).first <= t) {
			//отображаем фрагмент очереди
			std::cout << (ptd.first - ptd.second) << std::endl;
			Q.pop();
			//место в буфере увеличивается, если пакет попадал в буфер
			size += ptd.first >= 0 ? 1 : 0;
		}
		//если два пакета пришли одновременно, то второй сразу укладываем в очередь (без её проверки)
		t_old = t;
		//укладываем пакет в очередь
		if(size<=0) {
			//пакет не помещается в буфере и обрабатываться не будет
			Q.push({-1, 0});
			//место в буфере не меняется
		} else {
			//определяем время завершения обработки пакета
			if(time <= t)
				time = t + d; //пакет начинает обрабатывается в сразу
			else
				time += d;    //пакет начинает обрабатываться в порядке очереди
			Q.push({time, d});
			//место в буфере уменьшается
			--size;
		}		
	}

	//отображаем хвост очереди
	while(!Q.empty()) {
		std::pair<long long, long long> ptd = Q.front();
		std::cout << (ptd.first - ptd.second) << std::endl;
		Q.pop();
	}
		
	
	std::system("pause");
	return 0;
}