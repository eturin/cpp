/*¬осстановите строку по еЄ коду и беспрефиксному коду символов. 
¬ первой строке входного файла заданы два целых числа kk и ll через пробел Ч количество различных букв, встречающихс€ в строке, и размер получившейс€ закодированной строки, соответственно. ¬ следующих kk строках записаны коды букв в формате "letter: code". Ќи один код не €вл€етс€ префиксом другого. Ѕуквы могут быть перечислены в любом пор€дке. ¬ качестве букв могут встречатьс€ лишь строчные буквы латинского алфавита; кажда€ из этих букв встречаетс€ в строке хот€ бы один раз. Ќаконец, в последней строке записана закодированна€ строка. »сходна€ строка и коды всех букв непусты. «аданный код таков, что закодированна€ строка имеет минимальный возможный размер.

¬ первой строке выходного файла выведите строку ss. ќна должна состо€ть из строчных букв латинского алфавита. √арантируетс€, что длина правильного ответа не превосходит 10^4 символов.*/

#include <iostream>

class Node {
public:
	char c;
	Node * zero, *one;

	Node(const char c, Node * zero = NULL, Node * one = NULL):c(c), zero(zero), one(one) {};
	~Node() {
		delete zero, one;
	}
};

int main() {
	int n;
	unsigned long long len;
	std::cin >> n >> len;
	//строим дерево
	char c;
	Node * tree = new Node(0);
	Node * tr;
	for(int i = 0; i<n; ++i) {
		char ch;
		//берем символ, ":" и пробел
		(std::cin >> c).get();
		std::cin.get(); 
		//выстраиваем ветвь 
		tr = tree;
		while(std::cin.get(ch) && ch != '\n')
			if(ch == '0') {
				if(tr->zero == NULL)
					tr->zero = new Node(0);
				tr = tr->zero;
			} else {
				if(tr->one == NULL)
					tr->one = new Node(0);
				tr = tr->one;
			}
		//и укладываем символ
		tr->c = c;
	}
	//расшифоровываем ввод
	tr = tree;
	while(len-- && std::cin >> c) {
		if(c == '0')
			tr = tr->zero;
		else
			tr = tr->one;
		if(tr->one == NULL && tr->zero == NULL) {
			std::cout << tr->c;
			tr = tree;
		}
	}

	delete tree;

	system("pause");
	return 0;
}

